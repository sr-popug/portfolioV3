const blogsExp = [
	{
		id: 1,
		desc_img: 'Небольшой пример',
		title: 'Немного информации о React Reconciliation',
		pars: [
			{
				typeOfText: 'par',
				h: 'Определение',
				typeOfH: '2',
				text: 'React Reconciliation - ключевой процесс в React, обеспечивающий эффективную отрисовку компонентов. Он сравнивает виртуальное дерево компонентов с реальным DOM, обновляя лишь необходимые части. Это повышает производительность и ускоряет приложения. Алгоритм согласования React определяет изменения и применяет их, минимизируя нагрузку на браузер. Оптимизации, такие как использование ключей и батчинг обновлений, улучшают скорость работы. Практические примеры помогут понять, как применять React Reconciliation в проектах и избегать проблем. Следуя советам и лучшим практикам, можно достичь оптимальной производительности приложений.',
			},
			{
				typeOfText: 'par',
				h: 'Пакет react-reconcile',
				typeOfH: '3',
				text: 'Сложность процессу реконсиляции добавляет тот фактор, что сегодня существуют разные платформы где итоговый UI может быть выведен в другой формат. В частносwти, сам React предусматривает рендеринг в Web, серверный рендеринг (SSR), рендеринг на мобильных устройствах (React Native) и др.',
			},
			{
				typeOfText: 'par',
				text: 'В этой связи, команда React выделила отдельный пакет react-reconcile в качестве некоего абстрактного API. Этот пакет не осуществляет конечную привязку к DOM, а только обеспечивает всю необходимую механику по подготовке и манипуляции элементами. Сама же привязка к DOM осуществляется средствами внешнего провайдера, реализующего API пакета react-reconciler. Работа провайдера заключается в выставлении конкретных флагов настроек и описании методов-колбеков. Такой подход позволяет создавать разные провайдеры для разных случаев и платформ. ',
			},
			{
				typeOfText: 'par',
				typeOfH: '3',
				h: 'Рендеры',
				text: 'Провайдеры, реализующие API пакета react-reconciler, условно, называются рендеры.React предлагает несколько реализаций рендеров "из коробки:"',
			},
			{
				typeOfText: 'ul',
				li: [
					'React DOM - Он обеспечивает привязку к DOM-дереву браузера',
					'React Native - этот рендер обеспечивает нативный рендеринг на мобильных платформах',
					'React ART - позволяет рисовать векторную графику средствами React. Фактически, является реактивной оболочкой для библиотеки ART.',
				],
			},
			{
				typeOfText: 'par',
				typeOfH: '3',
				h: 'Fiber',
				text: 'А теперь познакомимся с базовой сущностью движка React. Fiber - это внутренний объект React, представляющий задачу ("работу"), которую движок запланировал к выполнению или уже выполнил.На основании этих объектов и будет работать пакет react-reconciler, о котором мы говорили чуть выше.',
			},
			{
				typeOfText: 'par',
				text: 'Во время согласования (reconciliation) данные каждого React элемента, возвращенные из метода render, объединяются в дерево fiber-узлов. Каждый React элемент имеет соответствующий fiber-узел. В отличие от React элементов, fibers не создаются заново при каждом рендере. Эти мутабельные структуры данных хранят состояние компонентов и DOM',
			},
			{
				typeOfText: 'par',
				text: 'Вы можете думать о Fiber как о структуре данных, которая представляет некоторую работу, которую нужно выполнить, или, другими словами, единицу работы. Архитектура Fiber также обеспечивает удобный способ отслеживания, планирования, приостановки и прерывания работы.',
			},
		],
		time: 5,
		date: '23.06.2024',
	},
	{
		id: 2,
		desc_img: '',
		title: 'Переосмысление семантической верстки в HTML5',
		pars: [
			{
				typeOfText: 'par',

				typeOfH: '2',
				h: 'Многие не правы!',
				text: 'Прочитав сотни статей и просмотрев часы видеороликов на эту тему, я осознал что многие люди, во-первых не понимают зачем им вообще нужна эта семантика, а во-вторых не понимают значение многих блочных структур. В этой статье я постараюсь рассказать понятным языком, чем же являются семантические теги и откуда ноги растут).',
			},
			{
				typeOfText: 'par',

				typeOfH: '3',
				h: 'Зачем всё это?',
				text: 'Самое главное, что мы должны осазновать, при семантической вёрстке,  так это то что парсер, читая код HTML, должен понимать смысл нашей страницы и каждого его блока в частности. И если даже мы уберем весь CSS и посмотрим на страницу мы всё равно должны понимать что и зачем нужно.',
			},
			{
				typeOfText: 'par',
				typeOfH: '3',
				h: 'Article и section - в чем собственно разница?',
				text: 'Article - это самостоятельный блог, который может существовать отдельно от других структур. Если мы вырежем такой блог из страницы, мы не потеряем логических связей между элементами. Внутри article могут быть другие article, которые также являются самостоятельными.',
			},
			{
				typeOfText: 'par',
				text: 'Section же является блоком характеристик и не может существовать отдельно от article и обязательно должен быть внутри него.',
			},
			{
				typeOfText: 'strong',
				text: 'Пример',
			},
			{
				typeOfText: 'par',
				text: 'Рассмотри пример на слове "Пиво". Пиво светлое и холодное, в этом случае:',
			},
			{
				typeOfText: 'ul',
				li: [
					'"Пиво" это article',
					'"Светлое и холодное" - section-ы потому что эти слова описывают характеристики одного объекта с разных сторон.',
				],
			},
			{
				typeOfText: 'par',
				text: 'Если бы мы написали Пиво - светлое и тёмное, то тогда Пиво, светлое и темное - это article-ы потому что мы не можем характеризовать пиво как светлое и темное одновременно.',
			},
			{
				typeOfText: 'par',
				typeOfH: '3',
				h: 'Сколько раз можно использовать Header и Footer на странице?',
				text: 'Header-ов и footer-ов может быть хоть сто на странице, они не обязательно означают главные шапку и подвал сайта, footer при желании может быть выше header если например у нас несколько разделов, в которых есть и header и footer',
			},
			{
				typeOfText: 'par',
				typeOfH: '3',
				h: 'Тег main - это не то, что вы думаете!',
				text: 'Многие считают, что main это главный блок сайта, в котором находиться основная информация со страницы. Но на самом деле это не так. Изначально планировалось сделать так, чтобы в теге body могло быть несколько страниц одновременно, такой некий зародыш SPA) Такие планы были из-за того что интернет на тот момент был медленным. Считали что тег main будет означать корневую страницу сайта, на которую пользователь попадает изначально. Сейчас же main лучше не использовать, а вместо него ставить тег article.',
			},
		],
		time: 6,
		date: '17.06.2024',
	},
]
export default blogsExp
